#!/usr/bin/env bash
#
# flocked - Simple process management for background tasks
#
# Usage: flocked <command> [options] [arguments]
#
set -euo pipefail

readonly VERSION="0.1.1"
readonly FLOCKED_DIR="${FLOCKED_DIR:-/tmp/flocked-$USER}"

# --- Output helpers ---

die() {
    printf '%s\n' "$*" >&2
    exit 1
}

# --- Directory management ---

_init_dir() {
    mkdir -p "$FLOCKED_DIR" || die "Failed to create state directory: $FLOCKED_DIR"
}

_process_dir() {
    printf '%s/%s' "$FLOCKED_DIR" "$1"
}

# --- Process helpers ---

_is_valid_name() {
    [[ "$1" =~ ^[a-zA-Z0-9_-]+$ ]]
}

_is_running() {
    local pid="$1"
    kill -0 "$pid" 2>/dev/null
}

_pgid_has_processes() {
    local pgid="$1"
    # Check if any process exists in this process group
    # Works on both Linux (pgrep) and macOS
    pgrep -g "$pgid" >/dev/null 2>&1
}

_read_meta() {
    local dir="$1" key="$2"
    # Never fail when the key is missing (important with set -e + pipefail).
    # If the key occurs multiple times (shouldn't happen), return the last one.
    local line value=""
    while IFS= read -r line; do
        [[ "$line" == "$key="* ]] || continue
        value="${line#*=}"
    done < "$dir/meta" 2>/dev/null || true
    printf '%s' "$value"
}

_get_status() {
    local dir="$1"
    local exitcode pid
    
    exitcode="$(_read_meta "$dir" exitcode)"
    if [[ -n "$exitcode" ]]; then
        printf 'exited %s' "$exitcode"
        return
    fi
    
    pid="$(_read_meta "$dir" pid)"
    if [[ -n "$pid" ]] && _is_running "$pid"; then
        printf 'running'
        return
    fi
    
    printf 'dead'
}

_format_time() {
    local ts="$1"
    if [[ -z "$ts" ]]; then
        printf 'unknown'
        return
    fi
    # Try to format timestamp; fall back to raw if date fails
    date -r "$ts" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || \
    date -d "@$ts" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || \
    printf '%s' "$ts"
}

_parse_timeout_seconds() {
    local raw="${1:-}"
    [[ -n "$raw" ]] || die "Missing value for --timeout"
    [[ "$raw" =~ ^[0-9]+$ ]] || die "Invalid timeout: '$raw' (must be integer seconds)"
    # shellcheck disable=SC2128
    (( raw >= 0 )) || die "Invalid timeout: '$raw' (must be >= 0)"
    printf '%s' "$raw"
}

_wait_for_exit() {
    local dir="$1"
    local name="$2"
    local timeout_seconds="$3"

    local meta_file="$dir/meta"
    [[ -f "$meta_file" ]] || die "No such process: $name"

    local start_seconds="$SECONDS"
    local pid exitcode

    # If the main PID is already dead, we briefly retry reading exitcode to
    # avoid reporting unknown status due to tiny write races.
    local dead_retries=0

    while true; do
        exitcode="$(_read_meta "$dir" exitcode)"
        if [[ -n "$exitcode" ]]; then
            [[ "$exitcode" =~ ^-?[0-9]+$ ]] || die "\"$name\" has invalid recorded exitcode: $exitcode"
            return "$exitcode"
        fi

        pid="$(_read_meta "$dir" pid)"
        [[ -n "$pid" ]] || die "\"$name\" has no pid recorded"

        if _is_running "$pid"; then
            dead_retries=0
            if (( SECONDS - start_seconds >= timeout_seconds )); then
                printf 'Timeout expired waiting for "%s" after %ss (still running, pid %s)\n' "$name" "$timeout_seconds" "$pid" >&2
                return 124
            fi
            sleep 0.1
            continue
        fi

        # Main PID is not running and exitcode isn't recorded.
        # Retry a few times quickly to allow meta updates; otherwise report unknown.
        if (( dead_retries < 10 )); then
            (( dead_retries++ )) || true
            sleep 0.05
            continue
        fi

        printf '"%s" is not running, but exit code is unknown\n' "$name" >&2
        return 1
    done
}

_kill_process_group() {
    local pgid="$1"
    local pid="${2:-}"
    
    # Try to kill by process group first (works on Linux, may fail on macOS)
    kill -TERM -- "-$pgid" 2>/dev/null || true
    
    # Also kill the main PID directly if provided
    [[ -n "$pid" ]] && kill -TERM "$pid" 2>/dev/null || true
    
    # Wait briefly for graceful shutdown
    local waited=0
    while (( waited < 30 )); do
        # Check if main process is still alive
        if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
        sleep 0.1
        (( waited++ )) || true
    done
    
    # Force kill if still alive
    kill -KILL -- "-$pgid" 2>/dev/null || true
    [[ -n "$pid" ]] && kill -KILL "$pid" 2>/dev/null || true
}

# --- Commands ---

cmd_run() {
    local force=0
    local do_wait=0
    local timeout_seconds=60
    
    # Parse flags
    while [[ $# -gt 0 && "$1" == -* ]]; do
        case "$1" in
            -f) force=1; shift ;;
            --wait) do_wait=1; shift ;;
            --timeout)
                shift
                timeout_seconds="$(_parse_timeout_seconds "${1:-}")"
                shift
                ;;
            *)  die "Unknown option: $1" ;;
        esac
    done
    
    [[ $# -ge 2 ]] || die "Usage: flocked run [-f] [--wait] [--timeout <seconds>] <name> <command...>"
    
    local name="$1"; shift
    local cmd=("$@")
    
    # Validate name
    _is_valid_name "$name" || die "Invalid name: '$name' (use alphanumeric, dash, underscore)"
    
    _init_dir
    local dir
    dir="$(_process_dir "$name")"
    
    # Handle existing process
    if [[ -d "$dir" ]]; then
        local existing_pid
        existing_pid="$(_read_meta "$dir" pid)"
        
        if [[ -n "$existing_pid" ]] && _is_running "$existing_pid"; then
            if (( force )); then
                local existing_pgid
                existing_pgid="$(_read_meta "$dir" pgid)"
                _kill_process_group "${existing_pgid:-$existing_pid}" "$existing_pid"
            else
                die "\"$name\" is already running (use -f to force)"
            fi
        fi
        
        # Clean up old directory
        rm -rf "$dir"
    fi
    
    # Create process directory
    mkdir -p "$dir"
    
    # Start process in a new session/process group
    # This ensures we can kill the entire process tree later
    # The wrapper captures exit code and writes it to meta file
    local pid pgid
    local meta_file="$dir/meta"
    local started
    started=$(date +%s)

    # Create/truncate meta file before launching to avoid races where a very
    # fast process writes exitcode before we write initial metadata.
    : > "$meta_file"
    
    # Wrapper script that runs command and captures exit code
    local wrapper='
        "$@"
        ec=$?
        printf "exitcode=%d\n" "$ec" >> "'"$meta_file"'"
        exit $ec
    '
    
    if command -v setsid >/dev/null 2>&1; then
        # Linux: setsid creates a new session
        setsid bash -c "$wrapper" _ "${cmd[@]}" >> "$dir/output.log" 2>&1 &
        pid=$!
        pgid=$pid
    else
        # macOS/BSD: use perl to create new session (perl is always available)
        # The perl process becomes the session leader, then execs bash
        perl -e '
            use POSIX qw(setsid);
            setsid() or die "setsid: $!";
            exec @ARGV or die "exec: $!";
        ' -- bash -c "$wrapper" _ "${cmd[@]}" >> "$dir/output.log" 2>&1 &
        pid=$!
        pgid=$pid
    fi
    
    # Write initial metadata (append; wrapper may have already written exitcode)
    cat >> "$meta_file" <<EOF
pid=$pid
pgid=$pgid
cmd=${cmd[*]}
started=$started
EOF
    
    printf 'Started "%s" (pid %d)\n' "$name" "$pid"

    if (( do_wait )); then
        _wait_for_exit "$dir" "$name" "$timeout_seconds"
    fi
}

cmd_wait() {
    local timeout_seconds=60

    while [[ $# -gt 0 && "$1" == -* ]]; do
        case "$1" in
            --timeout)
                shift
                timeout_seconds="$(_parse_timeout_seconds "${1:-}")"
                shift
                ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    [[ $# -eq 1 ]] || die "Usage: flocked wait [--timeout <seconds>] <name>"

    local name="$1"
    _is_valid_name "$name" || die "Invalid name: '$name' (use alphanumeric, dash, underscore)"

    _init_dir
    local dir
    dir="$(_process_dir "$name")"

    [[ -d "$dir" ]] || die "No such process: $name"

    _wait_for_exit "$dir" "$name" "$timeout_seconds"
}

cmd_ps() {
    _init_dir
    
    if [[ $# -eq 0 ]]; then
        # List all processes
        _ps_list
    else
        # Show details for specific process
        _ps_detail "$1"
    fi
}

_ps_list() {
    local name dir status output
    local found=0
    
    # Print header
    printf '%-12s %-12s %s\n' 'NAME' 'STATUS' 'OUTPUT'
    
    # List all process directories
    for dir in "$FLOCKED_DIR"/*/; do
        [[ -d "$dir" ]] || continue
        [[ -f "$dir/meta" ]] || continue
        
        # Remove trailing slash
        dir="${dir%/}"
        
        found=1
        name="$(basename "$dir")"
        status="$(_get_status "$dir")"
        output="$dir/output.log"
        
        printf '%-12s %-12s %s\n' "$name" "$status" "$output"
    done
    
    if (( ! found )); then
        printf '(no processes)\n'
    fi
}

_ps_detail() {
    local name="$1"
    local dir
    dir="$(_process_dir "$name")"
    
    if [[ ! -d "$dir" ]] || [[ ! -f "$dir/meta" ]]; then
        die "No such process: $name"
    fi
    
    local status pid pgid cmd started
    status="$(_get_status "$dir")"
    pid="$(_read_meta "$dir" pid)"
    pgid="$(_read_meta "$dir" pgid)"
    cmd="$(_read_meta "$dir" cmd)"
    started="$(_read_meta "$dir" started)"
    
    printf 'name: %s\n' "$name"
    printf 'status: %s\n' "$status"
    printf 'pid: %s\n' "$pid"
    printf 'pgid: %s\n' "$pgid"
    printf 'cmd: %s\n' "$cmd"
    printf 'started: %s\n' "$(_format_time "$started")"
    printf 'output: %s\n' "$dir/output.log"
}

cmd_kill() {
    [[ $# -ge 1 ]] || die "Usage: flocked kill <name>"
    
    local name="$1"
    local dir
    dir="$(_process_dir "$name")"
    
    # Check if process exists
    if [[ ! -d "$dir" ]] || [[ ! -f "$dir/meta" ]]; then
        die "No such process: $name"
    fi
    
    local pid pgid status
    pid="$(_read_meta "$dir" pid)"
    pgid="$(_read_meta "$dir" pgid)"
    status="$(_get_status "$dir")"
    
    # Check if already dead
    if [[ "$status" == exited* ]] || [[ "$status" == "dead" ]]; then
        printf '"%s" is not running (%s)\n' "$name" "$status"
        return 0
    fi
    
    # Kill the process group
    printf 'Killing "%s" (pid %s, pgid %s)...\n' "$name" "$pid" "$pgid"
    
    # Send SIGTERM to process group and main PID
    kill -TERM -- "-$pgid" 2>/dev/null || true
    [[ -n "$pid" ]] && kill -TERM "$pid" 2>/dev/null || true
    
    # Wait up to 5 seconds for graceful shutdown
    local waited=0
    while (( waited < 50 )); do
        # Check if main process and all group members are dead
        if ! _is_running "$pid" && ! _pgid_has_processes "$pgid"; then
            printf '"%s" terminated\n' "$name"
            return 0
        fi
        sleep 0.1
        (( waited++ )) || true
    done
    
    # Force kill entire process group if anything remains
    printf 'Sending SIGKILL...\n'
    kill -KILL -- "-$pgid" 2>/dev/null || true
    [[ -n "$pid" ]] && kill -KILL "$pid" 2>/dev/null || true
    
    # Wait briefly for SIGKILL to take effect
    sleep 0.2
    
    # Final verification
    if _is_running "$pid"; then
        die "Failed to kill \"$name\" (pid $pid)"
    fi
    
    printf '"%s" killed\n' "$name"
}

cmd_clean() {
    _init_dir
    
    if [[ $# -eq 0 ]]; then
        _clean_all
    else
        _clean_one "$1"
    fi
}

_clean_one() {
    local name="$1"
    local dir
    dir="$(_process_dir "$name")"
    
    # Check if process exists
    if [[ ! -d "$dir" ]] || [[ ! -f "$dir/meta" ]]; then
        die "No such process: $name"
    fi
    
    local status
    status="$(_get_status "$dir")"
    
    # Refuse to clean running processes
    if [[ "$status" == "running" ]]; then
        die "\"$name\" is still running (kill it first)"
    fi
    
    rm -rf "$dir"
    printf 'Cleaned "%s"\n' "$name"
}

_clean_all() {
    local name dir status
    local cleaned=0
    
    for dir in "$FLOCKED_DIR"/*/; do
        [[ -d "$dir" ]] || continue
        [[ -f "$dir/meta" ]] || continue
        
        dir="${dir%/}"
        status="$(_get_status "$dir")"
        
        # Skip running processes
        [[ "$status" == "running" ]] && continue
        
        name="$(basename "$dir")"
        rm -rf "$dir"
        (( cleaned++ )) || true
    done
    
    if (( cleaned == 0 )); then
        printf 'Nothing to clean\n'
    elif (( cleaned == 1 )); then
        printf 'Cleaned 1 process\n'
    else
        printf 'Cleaned %d processes\n' "$cleaned"
    fi
}

usage() {
    cat <<EOF
flocked $VERSION - Simple process management for background tasks

Usage: flocked <command> [options] [arguments]

Commands:
  run [-f] [--wait] [--timeout <seconds>] <name> <command...>
                                Start a background process (optionally wait)
  wait [--timeout <seconds>] <name>
                                Wait for an existing process to finish
  ps [name]                      List processes or show details
  kill <name>                    Kill process and all children
  clean [name]                   Remove stopped process(es)

Options:
  -h, --help     Show this help
  -v, --version  Show version

Environment:
  FLOCKED_DIR    State directory (default: /tmp/flocked-\$USER)

Examples:
  flocked run myserver ./server.sh --port 8080
  flocked run -f myserver ./server.sh    # Force replace if running
  flocked run --wait --timeout 60 job ./job.sh
  flocked wait --timeout 60 myserver
  flocked ps                             # List all processes
  flocked ps myserver                    # Show details for myserver
  flocked kill myserver                  # Kill myserver and children
  flocked clean myserver                 # Remove myserver's state
  flocked clean                          # Remove all stopped processes
EOF
}

# --- Main ---

main() {
    case "${1:-}" in
        run)   shift; cmd_run "$@" ;;
        wait)  shift; cmd_wait "$@" ;;
        ps)    shift; cmd_ps "$@" ;;
        kill)  shift; cmd_kill "$@" ;;
        clean) shift; cmd_clean "$@" ;;
        -h|--help)    usage ;;
        -v|--version) printf 'flocked %s\n' "$VERSION" ;;
        "")    usage; exit 1 ;;
        *)     die "Unknown command: $1 (try 'flocked --help')" ;;
    esac
}

main "$@"

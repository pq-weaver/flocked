#!/usr/bin/env bash
#
# flocked - Simple process management for background tasks
#
# Usage: flocked <command> [options] [arguments]
#
set -euo pipefail

readonly VERSION="0.1.0"
readonly FLOCKED_DIR="${FLOCKED_DIR:-/tmp/flocked-$USER}"

# --- Output helpers ---

die() {
    printf '%s\n' "$*" >&2
    exit 1
}

# --- Directory management ---

_init_dir() {
    mkdir -p "$FLOCKED_DIR" || die "Failed to create state directory: $FLOCKED_DIR"
}

_process_dir() {
    printf '%s/%s' "$FLOCKED_DIR" "$1"
}

# --- Process helpers ---

_is_valid_name() {
    [[ "$1" =~ ^[a-zA-Z0-9_-]+$ ]]
}

_is_running() {
    local pid="$1"
    kill -0 "$pid" 2>/dev/null
}

_pgid_has_processes() {
    local pgid="$1"
    # Check if any process exists in this process group
    # Works on both Linux (pgrep) and macOS
    pgrep -g "$pgid" >/dev/null 2>&1
}

_read_meta() {
    local dir="$1" key="$2"
    grep "^${key}=" "$dir/meta" 2>/dev/null | cut -d= -f2-
}

_get_status() {
    local dir="$1"
    local exitcode pid
    
    exitcode="$(_read_meta "$dir" exitcode)"
    if [[ -n "$exitcode" ]]; then
        printf 'exited %s' "$exitcode"
        return
    fi
    
    pid="$(_read_meta "$dir" pid)"
    if [[ -n "$pid" ]] && _is_running "$pid"; then
        printf 'running'
        return
    fi
    
    printf 'dead'
}

_format_time() {
    local ts="$1"
    if [[ -z "$ts" ]]; then
        printf 'unknown'
        return
    fi
    # Try to format timestamp; fall back to raw if date fails
    date -r "$ts" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || \
    date -d "@$ts" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || \
    printf '%s' "$ts"
}

_kill_process_group() {
    local pgid="$1"
    local pid="${2:-}"
    
    # Try to kill by process group first (works on Linux, may fail on macOS)
    kill -TERM -- "-$pgid" 2>/dev/null || true
    
    # Also kill the main PID directly if provided
    [[ -n "$pid" ]] && kill -TERM "$pid" 2>/dev/null || true
    
    # Wait briefly for graceful shutdown
    local waited=0
    while (( waited < 30 )); do
        # Check if main process is still alive
        if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
        sleep 0.1
        (( waited++ )) || true
    done
    
    # Force kill if still alive
    kill -KILL -- "-$pgid" 2>/dev/null || true
    [[ -n "$pid" ]] && kill -KILL "$pid" 2>/dev/null || true
}

# --- Commands ---

cmd_run() {
    local force=0
    
    # Parse -f flag
    while [[ $# -gt 0 && "$1" == -* ]]; do
        case "$1" in
            -f) force=1; shift ;;
            *)  die "Unknown option: $1" ;;
        esac
    done
    
    [[ $# -ge 2 ]] || die "Usage: flocked run [-f] <name> <command...>"
    
    local name="$1"; shift
    local cmd=("$@")
    
    # Validate name
    _is_valid_name "$name" || die "Invalid name: '$name' (use alphanumeric, dash, underscore)"
    
    _init_dir
    local dir
    dir="$(_process_dir "$name")"
    
    # Handle existing process
    if [[ -d "$dir" ]]; then
        local existing_pid
        existing_pid="$(_read_meta "$dir" pid)"
        
        if [[ -n "$existing_pid" ]] && _is_running "$existing_pid"; then
            if (( force )); then
                local existing_pgid
                existing_pgid="$(_read_meta "$dir" pgid)"
                _kill_process_group "${existing_pgid:-$existing_pid}" "$existing_pid"
            else
                die "\"$name\" is already running (use -f to force)"
            fi
        fi
        
        # Clean up old directory
        rm -rf "$dir"
    fi
    
    # Create process directory
    mkdir -p "$dir"
    
    # Start process in a new session/process group
    # This ensures we can kill the entire process tree later
    # The wrapper captures exit code and writes it to meta file
    local pid pgid
    local meta_file="$dir/meta"
    local started
    started=$(date +%s)
    
    # Wrapper script that runs command and captures exit code
    local wrapper='
        "$@"
        ec=$?
        printf "exitcode=%d\n" "$ec" >> "'"$meta_file"'"
        exit $ec
    '
    
    if command -v setsid >/dev/null 2>&1; then
        # Linux: setsid creates a new session
        setsid bash -c "$wrapper" _ "${cmd[@]}" >> "$dir/output.log" 2>&1 &
        pid=$!
        pgid=$pid
    else
        # macOS/BSD: use perl to create new session (perl is always available)
        # The perl process becomes the session leader, then execs bash
        perl -e '
            use POSIX qw(setsid);
            setsid() or die "setsid: $!";
            exec @ARGV or die "exec: $!";
        ' -- bash -c "$wrapper" _ "${cmd[@]}" >> "$dir/output.log" 2>&1 &
        pid=$!
        pgid=$pid
    fi
    
    # Write meta file BEFORE process can complete (avoids race condition)
    # The wrapper appends exitcode when process finishes
    cat > "$dir/meta" <<EOF
pid=$pid
pgid=$pgid
cmd=${cmd[*]}
started=$started
EOF
    
    printf 'Started "%s" (pid %d)\n' "$name" "$pid"
}

cmd_ps() {
    _init_dir
    
    if [[ $# -eq 0 ]]; then
        # List all processes
        _ps_list
    else
        # Show details for specific process
        _ps_detail "$1"
    fi
}

_ps_list() {
    local name dir status output
    local found=0
    
    # Print header
    printf '%-12s %-12s %s\n' 'NAME' 'STATUS' 'OUTPUT'
    
    # List all process directories
    for dir in "$FLOCKED_DIR"/*/; do
        [[ -d "$dir" ]] || continue
        [[ -f "$dir/meta" ]] || continue
        
        # Remove trailing slash
        dir="${dir%/}"
        
        found=1
        name="$(basename "$dir")"
        status="$(_get_status "$dir")"
        output="$dir/output.log"
        
        printf '%-12s %-12s %s\n' "$name" "$status" "$output"
    done
    
    if (( ! found )); then
        printf '(no processes)\n'
    fi
}

_ps_detail() {
    local name="$1"
    local dir
    dir="$(_process_dir "$name")"
    
    if [[ ! -d "$dir" ]] || [[ ! -f "$dir/meta" ]]; then
        die "No such process: $name"
    fi
    
    local status pid pgid cmd started
    status="$(_get_status "$dir")"
    pid="$(_read_meta "$dir" pid)"
    pgid="$(_read_meta "$dir" pgid)"
    cmd="$(_read_meta "$dir" cmd)"
    started="$(_read_meta "$dir" started)"
    
    printf 'name: %s\n' "$name"
    printf 'status: %s\n' "$status"
    printf 'pid: %s\n' "$pid"
    printf 'pgid: %s\n' "$pgid"
    printf 'cmd: %s\n' "$cmd"
    printf 'started: %s\n' "$(_format_time "$started")"
    printf 'output: %s\n' "$dir/output.log"
}

cmd_kill() {
    [[ $# -ge 1 ]] || die "Usage: flocked kill <name>"
    
    local name="$1"
    local dir
    dir="$(_process_dir "$name")"
    
    # Check if process exists
    if [[ ! -d "$dir" ]] || [[ ! -f "$dir/meta" ]]; then
        die "No such process: $name"
    fi
    
    local pid pgid status
    pid="$(_read_meta "$dir" pid)"
    pgid="$(_read_meta "$dir" pgid)"
    status="$(_get_status "$dir")"
    
    # Check if already dead
    if [[ "$status" == exited* ]] || [[ "$status" == "dead" ]]; then
        printf '"%s" is not running (%s)\n' "$name" "$status"
        return 0
    fi
    
    # Kill the process group
    printf 'Killing "%s" (pid %s, pgid %s)...\n' "$name" "$pid" "$pgid"
    
    # Send SIGTERM to process group and main PID
    kill -TERM -- "-$pgid" 2>/dev/null || true
    [[ -n "$pid" ]] && kill -TERM "$pid" 2>/dev/null || true
    
    # Wait up to 5 seconds for graceful shutdown
    local waited=0
    while (( waited < 50 )); do
        # Check if main process and all group members are dead
        if ! _is_running "$pid" && ! _pgid_has_processes "$pgid"; then
            printf '"%s" terminated\n' "$name"
            return 0
        fi
        sleep 0.1
        (( waited++ )) || true
    done
    
    # Force kill entire process group if anything remains
    printf 'Sending SIGKILL...\n'
    kill -KILL -- "-$pgid" 2>/dev/null || true
    [[ -n "$pid" ]] && kill -KILL "$pid" 2>/dev/null || true
    
    # Wait briefly for SIGKILL to take effect
    sleep 0.2
    
    # Final verification
    if _is_running "$pid"; then
        die "Failed to kill \"$name\" (pid $pid)"
    fi
    
    printf '"%s" killed\n' "$name"
}

usage() {
    cat <<EOF
flocked $VERSION - Simple process management for background tasks

Usage: flocked <command> [options] [arguments]

Commands:
  run [-f] <name> <command...>   Start a background process
  ps [name]                      List processes or show details
  kill <name>                    Kill process and all children

Options:
  -h, --help     Show this help
  -v, --version  Show version

Environment:
  FLOCKED_DIR    State directory (default: /tmp/flocked-\$USER)

Examples:
  flocked run myserver ./server.sh --port 8080
  flocked run -f myserver ./server.sh    # Force replace if running
  flocked ps                             # List all processes
  flocked ps myserver                    # Show details for myserver
  flocked kill myserver                  # Kill myserver and children
EOF
}

# --- Main ---

main() {
    case "${1:-}" in
        run)   shift; cmd_run "$@" ;;
        ps)    shift; cmd_ps "$@" ;;
        kill)  shift; cmd_kill "$@" ;;
        -h|--help)    usage ;;
        -v|--version) printf 'flocked %s\n' "$VERSION" ;;
        "")    usage; exit 1 ;;
        *)     die "Unknown command: $1 (try 'flocked --help')" ;;
    esac
}

main "$@"
